/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: jND4haQkMjdpXVH9tN144R
// Component: J0wHb5QZ4Pa2

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import Navbar from "../../Navbar"; // plasmic-import: hCuAnYyEatdq/component
import Button from "../../Button"; // plasmic-import: DVuV3lh8L2we/component
import { Embed } from "@plasmicpkgs/plasmic-basic-components";

import { LocaleValue, useLocale } from "./PlasmicGlobalVariant__Locale"; // plasmic-import: KemWC_IXZp7Y/globalVariant

import "@plasmicapp/react-web/lib/plasmic.css";

import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import plasmic_plasmic_rich_components_css from "../plasmic_rich_components/plasmic.module.css"; // plasmic-import: jkU633o1Cz7HrJdwdxhVHk/projectcss
import projectcss from "./plasmic.module.css"; // plasmic-import: jND4haQkMjdpXVH9tN144R/projectcss
import sty from "./PlasmicLexique.module.css"; // plasmic-import: J0wHb5QZ4Pa2/css

import CheckSvgIcon from "./icons/PlasmicIcon__CheckSvg"; // plasmic-import: umpGfCAaGpna/icon
import IconIcon from "./icons/PlasmicIcon__Icon"; // plasmic-import: kj2DLaVP_RvL/icon

createPlasmicElementProxy;

export type PlasmicLexique__VariantMembers = {};
export type PlasmicLexique__VariantsArgs = {};
type VariantPropType = keyof PlasmicLexique__VariantsArgs;
export const PlasmicLexique__VariantProps = new Array<VariantPropType>();

export type PlasmicLexique__ArgsType = { isChecked2?: boolean };
type ArgPropType = keyof PlasmicLexique__ArgsType;
export const PlasmicLexique__ArgProps = new Array<ArgPropType>("isChecked2");

export type PlasmicLexique__OverridesType = {
  root?: Flex__<"div">;
  main?: Flex__<"div">;
  navbar?: Flex__<typeof Navbar>;
  button?: Flex__<typeof Button>;
  text?: Flex__<"div">;
  input?: Flex__<"div">;
  adh?: Flex__<"div">;
  title?: Flex__<"div">;
  password?: Flex__<"div">;
  content?: Flex__<"div">;
  embedHtml?: Flex__<typeof Embed>;
};

export interface DefaultLexiqueProps {}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicLexique__RenderFunc(props: {
  variants: PlasmicLexique__VariantsArgs;
  args: PlasmicLexique__ArgsType;
  overrides: PlasmicLexique__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {},
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();

  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "button.shape",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => "round"
      },
      {
        path: "navbar.show",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      },
      {
        path: "lexiqueContent",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) => [
          {
            label: "Strat\u00e9gie diagnostique de l\u2019endom\u00e9triose",
            content:
              "<ul>\n<li>La strat\u00e9gie diagnostique de premi\u00e8re ligne mise en \u0153uvre par le m\u00e9decin g\u00e9n\u00e9raliste, la sage-femme et/ou le gyn\u00e9cologue repose sur l\u2019interrogatoire et/ou l\u2019examen clinique. En cas de sympt\u00f4mes et/ou signes cliniques une \u00e9chographie endovaginale de premi\u00e8re ligne pourrait \u00eatre pratiqu\u00e9e par le m\u00e9decin g\u00e9n\u00e9raliste, le gyn\u00e9cologue ou le radiologue.</li>\n<li>La strat\u00e9gie diagnostique de deuxi\u00e8me ligne mise en \u0153uvre par le gyn\u00e9cologue r\u00e9f\u00e9rent et un radiologue r\u00e9f\u00e9rent repose sur la r\u00e9alisation d\u2019une IRM pelvienne +/- \u00e9chographie endovaginale par un r\u00e9f\u00e9rent.</li>\n<li>La strat\u00e9gie de troisi\u00e8me ligne est d\u00e9di\u00e9e \u00e0 la stadification pr\u00e9op\u00e9ratoire et sera bas\u00e9e sur une d\u00e9cision de r\u00e9union de concertation pluridisciplinaire (RCP) et s\u2019appuie sur l\u2019utilisation de classifications diagnostiques en IRM (notamment dPEI). Lors de la RCP il pourra \u00eatre discut\u00e9 la r\u00e9alisation d\u2019une \u00e9choendoscopie rectale, d\u2019une ent\u00e9ro IRM ou d\u2019un coloscanner en compl\u00e9ment.</li>\n</ul>"
          },
          {
            label: "Indications de l\u2019IRM pelvienne",
            content:
              "<p>Plusieurs m\u00e9ta-analyses ont d\u00e9montr\u00e9 que l'IRM est recommand\u00e9e comme technique de deuxi\u00e8me ligne chez une patiente symptomatique en pr\u00e9sence de r\u00e9sultats n\u00e9gatifs \u00e0 l'\u00e9chographie.</p>\n<ul>\n<li>L\u2019IRM pelvienne \u00e0 vis\u00e9e diagnostique est recommand\u00e9e en seconde intention pour le diagnostic d\u2019endom\u00e9triose en cas d\u2019\u00e9chographie endovaginale n\u00e9gative ou douteuse apr\u00e8s \u00e9chec du traitement m\u00e9dical (Grade A). En cas d\u2019\u00e9chographie endovaginale non r\u00e9alisable, l\u2019IRM pelvienne est recommand\u00e9e en premi\u00e8re intention.</li>\n</ul>\n<p>Une troisi\u00e8me m\u00e9ta-analyse a montr\u00e9 que l'IRM est un examen pr\u00e9op\u00e9ratoire utile pour pr\u00e9dire la multifocalit\u00e9 de l\u2019EPP. En effet, l'IRM permet une cartographie exhaustive de toutes les localisations endom\u00e9triosiques et \u00e9value l'\u00e9tendue de la maladie, aidant ainsi \u00e0 la planification chirurgicale. Dans ce cadre, le d\u00e9veloppement de la classification telle que la classification <em>deep Pelvic Endometriosis Index</em> (dPEI) d\u00e9montre sa capacit\u00e9 de pr\u00e9dire avec pr\u00e9cision la dur\u00e9e de l'op\u00e9ration, la dur\u00e9e du s\u00e9jour hospitalier et les complications postop\u00e9ratoires potentielles. Le principal int\u00e9r\u00eat de cette classification est la corr\u00e9lation du score avec la pr\u00e9sence de localisations lat\u00e9rales.</p>\n<ul>\n<li>L\u2019IRM pelvienne est donc recommand\u00e9e dans le bilan pr\u00e9op\u00e9ratoire d\u2019une endom\u00e9triose pelvienne pour sa cartographie exhaustive, sa capacit\u00e9 \u00e0 planifier le geste chirurgical et sa capacit\u00e9 \u00e0 pr\u00e9dire le risque de complications postop\u00e9ratoires (Grade B).</li>\n</ul>"
          },
          {
            label: "Protocole IRM",
            content:
              "<h3>Pr\u00e9paration de la patiente</h3>\n<ul>\n<li>A jeun de 3 \u00e0 6 h</li>\n<li>Vessie en semi-r\u00e9pl\u00e9tion</li>\n<li>Pr\u00e9paration rectale (lavement ou suppositoires) avant l\u2019examen</li>\n<li>Injection IV d\u2019agent antip\u00e9ristaltiques en SC, IM ou IVD</li>\n<li>D\u00e9cubitus dorsal</li>\n<li>Opacification vaginale au gel d\u2019\u00e9chographie (optionnelle)</li>\n<li>Opacification rectale (optionnelle en seconde intention)</li>\n<li>Injection optionnelle de sels de gadolinium en cas de doute diagnostique ou masse annexielle ind\u00e9termin\u00e9e, atteinte endom\u00e9triosique de la paroi, ou des nerfs</li>\n<li>Antenne pelvienne en r\u00e9seau phas\u00e9</li>\n<li>Contention abdominopelvienne</li>\n</ul>\n<h3>S\u00e9quences</h3>\n<ul>\n<li>S\u00e9quences pond\u00e9r\u00e9es T2 sans saturation de la graisse : au moins 2 plans 2D-T2\n<ul>\n<li>S\u00e9quence sagittale, coupes \u2264 4 mm</li>\n<li>S\u00e9quence axiale pelvienne (cr\u00eates iliaques-pubis), coupes \u2264 4 mm</li>\n<li>S\u00e9quence additionnelle 3D-T2 recommand\u00e9e dans le bilan pr\u00e9op\u00e9ratoire et fortement conseill\u00e9e dans le bilan diagnostique initial / Alternative 2D-T2 coupes fines</li>\n</ul>\n</li>\n<li>S\u00e9quences pond\u00e9r\u00e9es T1 :\n<ul>\n<li>S\u00e9quence axiale pond\u00e9r\u00e9e 3D-T1 Dixon</li>\n<li>S\u00e9quences pond\u00e9r\u00e9es 2D ou 3D-T1 sans et avec saturation de la graisse en l\u2019absence de s\u00e9quence 3D-T1 Dixon disponible</li>\n</ul>\n</li>\n<li>S\u00e9quence visualisant les reins</li>\n</ul>\n<h3>Dans certaines situations</h3>\n<p>S\u00e9quence de diffusion (endom\u00e9triome atypique, masse annexielle ind\u00e9termin\u00e9e)</p>\n<p>S\u00e9quence T1 avec saturation de la graisse apr\u00e8s injection de gadolinium en cas d\u2019endom\u00e9triome atypique, d\u2019endom\u00e9triose de la paroi abdominale, ou d\u2019atteinte nerveuse</p>\n<p>S\u00e9quences en apn\u00e9e T1 avec suppression de graisse sur les coupoles diaphragmatiques en syst\u00e9matique ou sur points d\u2019appel clinique</p>"
          },
          {
            label: "Classification dPEI",
            content:
              "<ul>\n<li>Classification des l\u00e9sions d\u2019endom\u00e9triose profonde recommand\u00e9e par l\u2019HAS, la SIFEM et l\u2019ESUR</li>\n<li>Bas\u00e9e sur analyse compartimentale des l\u00e9sions d\u2019endom\u00e9triose profonde</li>\n<li>Un point par compartiment</li>\n<li>Point additionnel en cas d\u2019atteinte :\n<ul>\n<li>du vagin ou CRV</li>\n<li>de la base v\u00e9sicale</li>\n<li>dilatation ur\u00e9t\u00e9rale</li>\n<li>de la paroi pelvienne ML et PL</li>\n</ul>\n</li>\n</ul>"
          }
        ]
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: {},
    $refs
  });

  const globalVariants = ensureGlobalVariants({
    locale: useLocale()
  });

  return (
    <React.Fragment>
      <Head>
        <meta name="twitter:card" content="summary" />
        <title key="title">{PlasmicLexique.pageMetadata.title}</title>
        <meta
          key="og:title"
          property="og:title"
          content={PlasmicLexique.pageMetadata.title}
        />
        <meta
          key="twitter:title"
          name="twitter:title"
          content={PlasmicLexique.pageMetadata.title}
        />
      </Head>

      <style>{`
        body {
          margin: 0;
        }
      `}</style>

      <div
        data-plasmic-name={"root"}
        data-plasmic-override={overrides.root}
        data-plasmic-root={true}
        data-plasmic-for-node={forNode}
        className={classNames(
          projectcss.all,
          projectcss.root_reset,
          projectcss.plasmic_default_styles,
          projectcss.plasmic_mixins,
          projectcss.plasmic_tokens,
          plasmic_antd_5_hostless_css.plasmic_tokens,
          plasmic_plasmic_rich_components_css.plasmic_tokens,
          sty.root
        )}
      >
        <div
          data-plasmic-name={"main"}
          data-plasmic-override={overrides.main}
          className={classNames(projectcss.all, sty.main)}
        >
          <Navbar
            data-plasmic-name={"navbar"}
            data-plasmic-override={overrides.navbar}
            button2={
              <Button
                data-plasmic-name={"button"}
                data-plasmic-override={overrides.button}
                className={classNames("__wab_instance", sty.button)}
                onClick={async event => {
                  const $steps = {};

                  $steps["goToBilan"] = true
                    ? (() => {
                        const actionArgs = { destination: `/bilan` };
                        return (({ destination }) => {
                          if (
                            typeof destination === "string" &&
                            destination.startsWith("#")
                          ) {
                            document
                              .getElementById(destination.substr(1))
                              .scrollIntoView({ behavior: "smooth" });
                          } else {
                            __nextRouter?.push(destination);
                          }
                        })?.apply(null, [actionArgs]);
                      })()
                    : undefined;
                  if (
                    $steps["goToBilan"] != null &&
                    typeof $steps["goToBilan"] === "object" &&
                    typeof $steps["goToBilan"].then === "function"
                  ) {
                    $steps["goToBilan"] = await $steps["goToBilan"];
                  }
                }}
                onShapeChange={async (...eventArgs: any) => {
                  ((...eventArgs) => {
                    generateStateOnChangeProp($state, ["button", "shape"])(
                      eventArgs[0]
                    );
                  }).apply(null, eventArgs);

                  if (
                    eventArgs.length > 1 &&
                    eventArgs[1] &&
                    eventArgs[1]._plasmic_state_init_
                  ) {
                    return;
                  }
                }}
                shape={generateStateValueProp($state, ["button", "shape"])}
              >
                <div
                  data-plasmic-name={"text"}
                  data-plasmic-override={overrides.text}
                  className={classNames(
                    projectcss.all,
                    projectcss.__wab_text,
                    sty.text
                  )}
                >
                  {"Button"}
                </div>
              </Button>
            }
            className={classNames("__wab_instance", sty.navbar)}
            onShowChange={async (...eventArgs: any) => {
              generateStateOnChangeProp($state, ["navbar", "show"]).apply(
                null,
                eventArgs
              );

              if (
                eventArgs.length > 1 &&
                eventArgs[1] &&
                eventArgs[1]._plasmic_state_init_
              ) {
                return;
              }
            }}
            show={generateStateValueProp($state, ["navbar", "show"])}
          />

          <Stack__
            as={"div"}
            data-plasmic-name={"input"}
            data-plasmic-override={overrides.input}
            hasGap={true}
            className={classNames(projectcss.all, sty.input, {
              [sty.inputglobal_locale_en]: hasVariant(
                globalVariants,
                "locale",
                "en"
              ),
              [sty.inputglobal_locale_fr]: hasVariant(
                globalVariants,
                "locale",
                "fr"
              )
            })}
          >
            {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
              (() => {
                try {
                  return $state.lexiqueContent;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return [];
                  }
                  throw e;
                }
              })()
            ).map((__plasmic_item_0, __plasmic_idx_0) => {
              const currentItem = __plasmic_item_0;
              const currentIndex = __plasmic_idx_0;
              return (
                <Stack__
                  as={"div"}
                  data-plasmic-name={"adh"}
                  data-plasmic-override={overrides.adh}
                  hasGap={true}
                  className={classNames(projectcss.all, sty.adh)}
                  key={currentIndex}
                >
                  <div
                    data-plasmic-name={"title"}
                    data-plasmic-override={overrides.title}
                    className={classNames(projectcss.all, sty.title, {
                      [sty.titleglobal_locale_en]: hasVariant(
                        globalVariants,
                        "locale",
                        "en"
                      )
                    })}
                  >
                    <div
                      data-plasmic-name={"password"}
                      data-plasmic-override={overrides.password}
                      className={classNames(
                        projectcss.all,
                        projectcss.__wab_text,
                        sty.password,
                        {
                          [sty.passwordglobal_locale_en]: hasVariant(
                            globalVariants,
                            "locale",
                            "en"
                          )
                        }
                      )}
                    >
                      {hasVariant(globalVariants, "locale", "en") ? (
                        <React.Fragment>
                          {(() => {
                            try {
                              return currentItem.label;
                            } catch (e) {
                              if (
                                e instanceof TypeError ||
                                e?.plasmicType === "PlasmicUndefinedDataError"
                              ) {
                                return "Adh\u00e9rence";
                              }
                              throw e;
                            }
                          })()}
                        </React.Fragment>
                      ) : (
                        <React.Fragment>
                          {(() => {
                            try {
                              return currentItem.label;
                            } catch (e) {
                              if (
                                e instanceof TypeError ||
                                e?.plasmicType === "PlasmicUndefinedDataError"
                              ) {
                                return "Adh\u00e9rence";
                              }
                              throw e;
                            }
                          })()}
                        </React.Fragment>
                      )}
                    </div>
                  </div>
                  <div
                    data-plasmic-name={"content"}
                    data-plasmic-override={overrides.content}
                    className={classNames(projectcss.all, sty.content)}
                  >
                    <Embed
                      data-plasmic-name={"embedHtml"}
                      data-plasmic-override={overrides.embedHtml}
                      className={classNames("__wab_instance", sty.embedHtml, {
                        [sty.embedHtmlglobal_locale_en]: hasVariant(
                          globalVariants,
                          "locale",
                          "en"
                        )
                      })}
                      code={(() => {
                        try {
                          return currentItem.content;
                        } catch (e) {
                          if (
                            e instanceof TypeError ||
                            e?.plasmicType === "PlasmicUndefinedDataError"
                          ) {
                            return "<div>Paste your embed code via the right sidebar</div>";
                          }
                          throw e;
                        }
                      })()}
                    />
                  </div>
                </Stack__>
              );
            })}
          </Stack__>
        </div>
      </div>
    </React.Fragment>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: [
    "root",
    "main",
    "navbar",
    "button",
    "text",
    "input",
    "adh",
    "title",
    "password",
    "content",
    "embedHtml"
  ],
  main: [
    "main",
    "navbar",
    "button",
    "text",
    "input",
    "adh",
    "title",
    "password",
    "content",
    "embedHtml"
  ],
  navbar: ["navbar", "button", "text"],
  button: ["button", "text"],
  text: ["text"],
  input: ["input", "adh", "title", "password", "content", "embedHtml"],
  adh: ["adh", "title", "password", "content", "embedHtml"],
  title: ["title", "password"],
  password: ["password"],
  content: ["content", "embedHtml"],
  embedHtml: ["embedHtml"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
  main: "div";
  navbar: typeof Navbar;
  button: typeof Button;
  text: "div";
  input: "div";
  adh: "div";
  title: "div";
  password: "div";
  content: "div";
  embedHtml: typeof Embed;
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicLexique__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicLexique__VariantsArgs;
    args?: PlasmicLexique__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicLexique__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    // Specify args directly as props
    Omit<PlasmicLexique__ArgsType, ReservedPropsType> &
    // Specify overrides for each element directly as props
    Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    // Specify props for the root element
    Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicLexique__ArgProps,
          internalVariantPropNames: PlasmicLexique__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicLexique__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicLexique";
  } else {
    func.displayName = `PlasmicLexique.${nodeName}`;
  }
  return func;
}

export const PlasmicLexique = Object.assign(
  // Top-level PlasmicLexique renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    main: makeNodeComponent("main"),
    navbar: makeNodeComponent("navbar"),
    button: makeNodeComponent("button"),
    text: makeNodeComponent("text"),
    input: makeNodeComponent("input"),
    adh: makeNodeComponent("adh"),
    title: makeNodeComponent("title"),
    password: makeNodeComponent("password"),
    content: makeNodeComponent("content"),
    embedHtml: makeNodeComponent("embedHtml"),

    // Metadata about props expected for PlasmicLexique
    internalVariantProps: PlasmicLexique__VariantProps,
    internalArgProps: PlasmicLexique__ArgProps,

    // Page metadata
    pageMetadata: {
      title: "dPEI Pocket",
      description: "",
      ogImageSrc: "",
      canonical: ""
    }
  }
);

export default PlasmicLexique;
/* prettier-ignore-end */
